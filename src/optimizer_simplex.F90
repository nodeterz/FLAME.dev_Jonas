!*****************************************************************************************
!Based on the paper by J. A. Nelder and R. Mead in 1965,
!vol. 7, p.p. 308, "A simplex method for function minimization"
subroutine simplex(vertices,fval,step,ndim,ftol,functn,iter)
    implicit none
    integer, intent(in):: ndim
    real(8), intent(in):: ftol, step
    real(8), intent(inout):: vertices(ndim,ndim+1), fval(ndim+1)
    integer, intent(out):: iter
    !local variables
    integer:: ml !The index of vertex with the lowest function value.
    integer:: mh !The index of vertex with the highest function value.
    integer:: msh !The index of vertex with the second highest function value.
    integer:: i, j, nvertices
    real(8):: rtol, fval_s, fval_ss, ybar, fdiff_rmse
    real(8), parameter:: alpha=1.d0 !reflection coefficient, a positive value
    real(8), parameter:: beta=0.5d0 !contraction coefficient, greater than one
    real(8), parameter:: gama=2.d0 !expansion coefficient, lies between zero and one
    integer, parameter:: nmax=20, itmax=50000
    !Expected maximum number of dimensions, three parameters which define
    !the expansions and contractions, and maximum allowed number of
    !iterations.
    real(8), allocatable:: vertex_s(:), vertex_ss(:), vertex_bar(:)
interface
    subroutine functn(n,p,func)
        implicit none
        integer, intent(in)  :: n
        real(8), intent(in)  :: p(n)
        real(8), intent(out) :: func
    end subroutine functn
end interface
    allocate(vertex_s(nmax),vertex_ss(nmax),vertex_bar(nmax))
    !Construct the simplex
    if(step/=0.d0) then
        do i=1,ndim
            do j=1,ndim
                vertices(j,i+1)=vertices(j,1)
            enddo
            vertices(i,i+1) = vertices(i,1)+step
        enddo
    else
        write(*,*) 'WARNING: step=0 so user must have provided the simplex.'
    endif
    !Evaluate the function at simplex ndim+1 vertices
    do i=1,ndim+1
        call functn(ndim,vertices(1,i),fval(i))
    enddo
    nvertices=ndim+1
    iter=0
    do
        !Finding the vertices with lowest, highest and second highest function values.
        ml=minloc(fval(1:nvertices),dim=1)
        mh=maxloc(fval(1:nvertices),dim=1)
        msh=ml
        do i=1,nvertices
            if(fval(i)>fval(msh) .and. i/=mh) msh=i
        enddo
        !Calculating the centroid of simplex except the vertex
        !with highest function value.
        do j=1,ndim
            vertex_bar(j)=0.d0
        enddo
        do i=1,nvertices
            if(i/=mh) then
                do j=1,ndim
                    vertex_bar(j)=vertex_bar(j) + vertices(j,i)
                enddo
            endif
        enddo
        do j=1,ndim
            vertex_bar(j)=vertex_bar(j)/ndim
        enddo
        !calculating the function value at the centroid.
        call functn(ndim,vertex_bar,ybar)
        !calculating the deviation of functions values at all vertices
        !from the value at the centroid that is used as the stopping criterion.
        fdiff_rmse=0.d0
        do j=1,ndim+1
            fdiff_rmse=fdiff_rmse+(fval(j)-ybar)**2
        enddo
        fdiff_rmse=sqrt(fdiff_rmse/real(ndim+1,8))
        write(*,'(a,i8,es14.5)') 'iter,fdiff_rmse ',iter,fdiff_rmse
        !checking whether simplex routine has converged.
        if(fdiff_rmse<ftol) then
            deallocate(vertex_s,vertex_ss,vertex_bar)
            return
        endif
        if(iter==itmax) then
            write(*,*) 'WARNING: simplex routine did not converge! itmax= ',itmax
            deallocate(vertex_s,vertex_ss,vertex_bar)
            return
        endif
        !Generating a new vertex by reflection.
        do j=1,ndim
            vertex_s(j)=(1.d0+alpha)*vertex_bar(j)-alpha*vertices(j,mh)
        enddo
        call functn(ndim,vertex_s,fval_s)
        !new point generated by reflection: there are four conditions three of which
        !the new point is used in some way and these three are listed below.
        if(.not. (fval_s>fval(ml))) then
            !The generated point with reflection looks good, let's expand the simplex
            do j=1,ndim
                vertex_ss(j)=gama*vertex_s(j)+(1.d0-gama)*vertex_bar(j)
            enddo
            call functn(ndim,vertex_ss,fval_ss)
            if(fval_ss<fval(ml)) then
                !Accepting the vertex generated by expansion operation.
                do j=1,ndim
                    vertices(j,mh)=vertex_ss(j)
                enddo
                fval(mh)=fval_ss
            else
                !Accepting the vertex generated by reflection operation.
                do j=1,ndim
                    vertices(j,mh)=vertex_s(j)
                enddo
                fval(mh)=fval_s
            endif
        else if(.not. (fval_s<fval(msh))) then
            if(fval_s<fval(mh)) then
                !Accepting the vertex generated by reflection operation.
                do j=1,ndim
                    vertices(j,mh)=vertex_s(j)
                enddo
                fval(mh)=fval_s
            endif
            !Performing contraction operation.
            do j=1,ndim
                vertex_ss(j)=beta*vertices(j,mh) + (1.d0-beta)*vertex_bar(j)
            enddo
            call functn(ndim,vertex_ss,fval_ss)
            if(fval_ss<fval(mh)) then
                !Accepting the vertex generated by contraction operation.
                do j=1,ndim
                    vertices(j,mh)=vertex_ss(j)
                enddo
                fval(mh)=fval_ss
            else
                !Contraction failed so all vertices are replaced by their corresponding
                !middle point between them and the vertex with the lowest function value.
                do i=1,nvertices
                    if(i/=ml) then
                        do j=1,ndim
                            vertices(j,i)=0.5d0*(vertices(j,i)+vertices(j,ml))
                        enddo
                        call functn(ndim,vertices(1,i),fval(i))
                    endif
                enddo
            endif
        else
            !Accepting the vertex generated by reflection operation.
            do j=1,ndim
                vertices(j,mh)=vertex_s(j)
            enddo
            fval(mh)=fval_s
        endif
        iter=iter+1
    enddo
end subroutine simplex
!*****************************************************************************************
